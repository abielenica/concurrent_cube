package concurrentcube;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import java.time.Duration;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

import static org.junit.jupiter.api.Assertions.assertTimeoutPreemptively;

class CubeTest {
    private final Cube cubeSize1;
    private final Cube cubeSize3;
    private final Cube sleepingCube;
    private Cube cubeSize4;
    private List<String> showResults;

    public CubeTest() {
        var counter = new Object() {
            int value = 0;
        };

        cubeSize1 = new Cube(1,
                (x, y) -> ++counter.value,
                (x, y) -> ++counter.value,
                () -> ++counter.value,
                () -> ++counter.value
        );
        cubeSize3 = new Cube(3,
                (x, y) -> ++counter.value,
                (x, y) -> ++counter.value,
                () -> ++counter.value,
                () -> ++counter.value
        );
        cubeSize4 = new Cube(4,
                (x, y) -> ++counter.value,
                (x, y) -> ++counter.value,
                () -> ++counter.value,
                () -> ++counter.value
        );
        sleepingCube = new Cube(4,
                (x, y) -> {
                    try {
                        Thread.sleep(1000);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                },
                (x, y) -> ++counter.value,
                () -> ++counter.value,
                () -> ++counter.value
        );

        showResults = Collections.synchronizedList(new ArrayList<String>());
    }

    @BeforeEach
    private void initalize() {
        var counter = new Object() {
            int value = 0;
        };
        cubeSize4 = new Cube(4,
                (x, y) -> ++counter.value,
                (x, y) -> ++counter.value,
                () -> ++counter.value,
                () -> ++counter.value
        );
        showResults = Collections.synchronizedList(new ArrayList<String>());
    }

    private int getRandomInt(int min, int max) {
        return ThreadLocalRandom.current().nextInt(min, max + 1);
    }

    /**
     * Tests the correctness of performing sequential rotations on a one-sized cube.
     * Expected result was generated by applying the rotations manually.
     */
    @Test
    void rotateCubeSize1Seq() throws Exception {
        String expected = "023415";
        cubeSize1.rotate(1, 0);
        cubeSize1.rotate(0, 0);
        cubeSize1.rotate(2, 0);
        assert (expected.equals(cubeSize1.show()));
    }

    /**
     * Tests the correctness of performing sequential rotations on a three-sized cube.
     * Expected result was generated by applying the rotations manually.
     */
    @Test
    void rotateCubeSize3Seq() throws Exception {
        String expected = "000142444250554121333111220504200303111333544552324552";
        cubeSize3.rotate(1, 2);
        cubeSize3.rotate(5, 1);
        cubeSize3.rotate(0, 0);
        cubeSize3.rotate(2, 1);
        assert (expected.equals(cubeSize3.show()));
    }

    /**
     * Tests the correctness of performing sequential rotations on a four-sized cube.
     * Expected result was generated by applying the rotations manually.
     */
    @Test
    void rotateCubeSize4Seq() throws Exception {
        String expected = "000044440000141445451115454211152121212101012121020203330202033333334544333345443232552555255525";
        cubeSize4.rotate(1, 2);
        cubeSize4.rotate(5, 1);
        cubeSize4.rotate(5, 3);
        cubeSize4.rotate(2, 0);
        assert (expected.equals(cubeSize4.show()));
    }

    /**
     * Tests if concurrent execution of the show() method on a randomly generated cube
     * returns the same result for each thread.
     */
    @Test
    void testShowConcurrent() throws Exception {
        for (int i = 0; i < 11; i++) {
            cubeSize4.rotate(getRandomInt(0, 5), getRandomInt(0, 3));
        }
        ArrayList<Thread> threads = new ArrayList<>();
        for (int i = 0; i < 11; i++) {
            Thread t = new Thread(new cubeSize4Shower());
            threads.add(t);
        }
        for (Thread t : threads) {
            t.start();
        }
        for (Thread t : threads) {
            t.join();
        }
        for (String s : showResults) {
            assert (s.equals(showResults.get(0)));
        }
    }

    /**
     * Tests if randomised concurrent execution of rotate() method causes deadlock.
     */
    @Test
    void testDeadlock() throws Exception {
        assertTimeoutPreemptively(Duration.ofMinutes(2), () -> {
            ArrayList<Thread> threads = new ArrayList<>();
            for (int i = 0; i < 15; i++) {
                Thread t1 = new Thread(new cubeSize4Mover());
                Thread t2 = new Thread(new cubeSize4Shower());
                threads.add(t1);
                threads.add(t2);
            }
            for (Thread t : threads) {
                t.start();
            }
            for (Thread t : threads) {
                t.join();
            }
        });
    }

    /**
     * Checks whether after a randomised concurrent execution of rotate() on a 4-sized cube
     * numbers of blocks of each color are correct.
     */
    @Test
    void rotateCubeSize4Concurrent() throws Exception {
        int[] blockColors = new int[6];
        ArrayList<Thread> threads = new ArrayList<>();
        for (int i = 0; i < 10; i++) {
            Thread t = new Thread(new cubeSize4Mover());
            threads.add(t);
        }
        for (Thread t : threads) {
            t.start();
        }
        for (Thread t : threads) {
            t.join();
        }
        for (int i = 0; i < 6; i++) {
            for (int j = 0; j < 4; j++) {
                for (int block : cubeSize4.getColumn(i, j)) {
                    blockColors[block]++;
                }
            }
        }
        for (int result : blockColors) {
            assert (result == 16);
        }
    }

    /**
     * Tests if execution of rotate() is actually concurrent by measuring time
     * spent performing two independent rotations.
     */
    @Test
    void sleepingCube() throws Exception {
        assertTimeoutPreemptively(Duration.ofSeconds(2), () -> {
            ArrayList<Thread> threads = new ArrayList<>();
                Thread t1 = new Thread(() -> {
                    try {
                        sleepingCube.rotate(0, 2);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                });
                Thread t2 = new Thread(() -> {
                    try {
                        sleepingCube.rotate(5, 0);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                });
                threads.add(t1);
                threads.add(t2);
            for (Thread t : threads) {
                t.start();
            }
            for (Thread t : threads) {
                t.join();
            }
        });
    }


    private class cubeSize4Shower implements Runnable {
        @Override
        public void run() {
            try {
                showResults.add(cubeSize4.show());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private class cubeSize4Mover implements Runnable {
        @Override
        public void run() {
            for (int i = 0; i < 100000; i++) {
                try {
                    cubeSize4.rotate(getRandomInt(0, 5), getRandomInt(0, 3));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}